{"categories":[{"title":"数据结构与算法","uri":"https://wst-casd.github.io/wst.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"posts":[{"content":"1 定义  桶排序（Bucket Sort）是一种线性时间的排序算法，其主要思想是：将待排序集合中处于同一个值域范围内的元素存入同一个桶中，也就是根据元素值特性将集合拆分为多个区域，拆分后形成的多个桶，从值域上看是处于有序状态的。对每个桶中元素进行排序，则所有桶中元素构成的集合是已排序的。\n 桶排序是计数排序 的扩展版本，计数排序可以看成每个桶只存储相同的元素，而桶排序每个桶存储一定范围内的元素。桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效。\n2 算法  桶排序的第一步，就是创建这些桶，确定每一个桶的区间范围：\n 具体建立多少个桶，如何确定桶的区间范围，有很多不同的方式。本文中创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定。\n区间跨度 = （最大值-最小值）/ （桶的数量 - 1）\n第二步，遍历原始数列，把元素对号入座放入各个桶中\n 第三步，每个桶内部的元素分别排序（显然，只有第3个桶需要排序）\n 第四步，遍历所有的桶，输出所有元素\n0.5, 1.68, 2.7, 3.25, 4.8, 5.5\n代码实现如下： def bucket_sort(lst): if lst: min_num = min(lst) max_num = max(lst) d = max_num - min_num bucket_len = len(lst) bucket_list = [ [] for i in range(backet_len) ] # 向桶数组中填数 for i in lst: bucket_list[int((i-min_num)*(bucket_len-1)/d)].append(i) # 回填，这里桶内部排序直接调用了sorted lst.clear() for i in bucket_list: for j in sorted(i): lst.append(j)\n3 算法分析 时间复杂度 对于待排序序列大小为$n$，共分为$m$个桶 第一步求数列最大最小值，运算量为$n$ 第二步创建空桶，运算量为$m$ 第三步遍历原始数列，运算量为$n$ 第四步在每个桶内部做排序，由于使用了O($nlogn$)的排序算法，所以运算量为 $n/m * log(n/m ) * m$ 第五步输出排序数列，运算量为$n$。\n综合来看，平均时间复杂度为O($3n + m + nlog(n/m)$)\n空间复杂度 桶排序过程中，需要创建$m$个桶的额外空间，以及$n$个元素的额外空间，所以桶排序的空间复杂度为O($n+k$)\n稳定性 桶排序的稳定性取决于桶内部排序使用的算法。由于桶内部排序可以做到稳定，所以桶排序是稳定的排序算法。\n","id":0,"section":"posts","summary":"1 定义 桶排序（Bucket Sort）是一种线性时间的排序算法，其主要思想是：将待排序集合中处于同一个值域范围内的元素存入同一个桶中，也就是根","tags":["排序","桶排序"],"title":"数据结构基础之桶排序","uri":"https://wst-casd.github.io/wst.github.io/2021/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A1%B6%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 定义  计数排序（Counting Sort）是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数进行排序时，它的时间复杂度为O($n+m$)(其中$m$是整数的范围): 它通过统计给定数组中不同元素的数量(类似于哈希映射)，然后对映射后的数组进行顺序输出即可。\n2 算法  例1：给定一组数据[9，1，2，7，8，1，3，6，5，3，4，0，10，9，7，9], 下面针对这个数组来分析计数排序的过程。\n 可知数据的范围是在0～10之间，一共11个元素，我们定义一个元素为0的长度为11的统计数组：\n 从左向右遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。 比如第一个整数是9，那么数组下标为9的元素加1：\n 第二个整数是1，那么数组下标为1的元素加1：  继续遍历数列并修改数组... 最终，数列遍历完毕时，数组的状态如下：\n 数组每一个下标位置的值，代表了数列中对应整数出现的次数。 有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：\n0, 1, 1, 2, 3, 3, 4, 5, 6, 7, 7, 8, 9, 9, 9, 10\n显然，这个输出的数列已经是有序的了。\n代码实现如下： def counting_sort(lst): if lst: bucket_len = max(lst) + 1 bucket = [0] * bucket_len for a in lst: bucket[a] += 1 lst.clear() for i in range(bucket_len): while bucket[i] \u0026gt; 0: lst.append(i) bucket[i] -= 1\n3 优化 3.1 空间位置浪费的问题  上述的代码实现过程以数组最大元素来决定统计数组的长度，这是可能待造成统计数组的空间浪费。\n例： 数组为[95，94，91，98，99，90，99，93，91，92].\n此时，数组最大元素为99，如果创建长度为100的统计数组，那前面0～89的位置就浪费了。\n如何解决这个问题呢？\n很简单，我们不再以（输入数列的最大值+1）作为统计数组的长度，而是以（数列最大值和最小值的差+1）作为统计数组的长度。\n同时，数列的最小值作为一个偏移量，用于统计数组的对号入座。\n以刚才的数列为例，统计数组的长度为 99 - 90 + 1 = 10 ，偏移量等于数列的最小值 90 。\n对于第一个整数95，对应的统计数组下标是 95 - 90 = 5，如图所示：\n 3.2 稳定排序(实际应用场景的考虑)  上面的排序对于处理纯数字没有什么问题，但是在实际场景中，例如给学生成绩排序问题，就会遇到相同分数分不清是谁(也就是上述的算法不是稳定的)。\n \u0026emsp;\u0026emsp;给定一个学生的成绩表，要求按成绩从低到高排序，如果成绩相同，则遵循原表固有顺序。  但是，当我们填充统计数组以后，我们只知道有两个成绩并列88分的小伙伴，却不知道哪一个是小陈，哪一个是小苏。（也就是稳定性没办法保持）\n为了保证计数排序的稳定性，我们又该如何做呢？\n 从上面的描述我们知道，数组 bucket 中的每一个值表示它所对应的下标在排序后数组的出现次数，那么我们遍历数组(下标从 1 开始)，并对数组 bucket 中的每一个元素执行 bucket[$i$] = bucket[$i$] + bucket[$i-1$] 会得到什么呢？\n \u0026emsp;\u0026emsp;此时得到新的 bucket[] 将表示他们的位置信息，比如:下标 0 位置的 1 表示下标 0 最终出现在第 1 的位置； 下标 2 位置的 3 表示下标3最终出现在 第 2 和第 3 的位置，依次类推，你也可以对新的 bucket 数组中的每一个元素做出解释。 有了这个新的 bucket 数组，我们如何得到元素数组 lst 在排序后的正确位置呢？\n第一步，从后往前遍历数组lst。首先，$i=9$，然后计算除lst[$i$] = lst[9] = 92, 在排序后的正确位置为 bucket[lst[$i$] - min] - 1 = bucket[lst[9] - 90] - 1 = 3, 即排序后lst[9]的正确位置是3，然后将lst[9]赋值给 output[3] = 92， 同时，bucket[lst[9] - min] = bucket[2] 减 1\n 第二步，$i=8$，然后计算除lst[$i$] = lst[8] = 91, 在排序后的正确位置为 bucket[lst[$i$] - min] - 1 = bucket[lst[8] - 90] - 1 = 2, 即排序后lst[8]的正确位置是2，然后将lst[8]赋值给 output[2] = 91， 同时，bucket[lst[8] - min] = bucket[1] 减 1  以此类推，就可以得到原数组 lst[] 中每一个元素在排序后的正确位置  这就是稳定的计数排序，那我们再来回答一下为什么从后向前遍历新的 lst[] 数组？ 因为只有这样才能保证计数排序的稳定性！比如原始数组 lst[] 中 2 个 91 的在排序后的相对位置就没有发生变化，依旧保持：\n 3.3 负整数元素的引入  如果数组变成了 lst[] = {-1, 4, -1, -2, 5, -2, 4, -1, 8} ，上面3.1介绍的计数排序的优化方式可以满足。只需要将最小元素映射到下标为0的位置。具体如下：\n 其中数组 lst[] 的最小值 min = -2 ，-2 被映射到了 bucket[] 数组下标为 0 的位置，原数组中包含 2 个 -2 ，所以 bucket[0] = 2 ；原数组 lst[] 当中有 3 个 -1 ，其中 -1 - (-2) = 1 ，也就说 -1 映射到了 lst[] 数组下表为 1 的位置，所以 bucket[1] = 3 . 得到了 bucket[] 数组以后，后面的操作和上面3.2类似即可。 具体代码实现如下： def counting_sort_opitimize(lst): if lst: # 1 求bucket长度 bucket_len = max(lst) - min(lst) + 1 bucket = [0] * bucket_len output = [0] * len(lst) min_elem = min(lst) # 2 统计对应元素个数 for a in lst: bucket[a - min_elem] += 1 # 3 统计数组做变形，后面的元素等于前面的元素之和 for i in range(1, bucket_len): bucket[i] += bucket[i-1] # 4 倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组 for elem in lst[::-1]: output[bucket[elem - min_elem] - 1] = elem bucket[elem - min_elem] -= 1 # 5 排序结果赋给原数列 for i in range(len(lst)): lst[i] = output[i] \n4 算法分析 4.1 复杂度分析  可以看出时间复杂为O(5n + m)(其中n为数列长度，m为统计数组长度)，空间复杂度为0(n).\n4.2 计数算法的局限性 1.当数列最大最小值差距过大时，并不适用计数排序。\n比如给定20个随机整数，范围在0到1亿之间，这时候如果使用计数排序，需要创建长度1亿的数组。不但严重浪费空间，而且时间复杂度也随之升高。\n2.当数列元素不是整数，并不适用计数排序。\n如果数列中的元素都是小数，比如25.213，或是0.00000001这样子，则无法创建对应的统计数组。这样显然无法进行计数排序\n5 参考 [1] 漫画：什么是计数排序？\n[2] 漫画图解：什么是计数排序？\n","id":1,"section":"posts","summary":"1 定义 计数排序（Counting Sort）是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数进行排序时，它的时间复杂度为O($n+","tags":["排序","计数排序"],"title":"数据结构基础之计数排序","uri":"https://wst-casd.github.io/wst.github.io/2021/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 定义  堆排序是一种高效的选择排序算法。\n 基于堆 的概念， 该算法高效的主要原因是在堆里积累了前面所做的比较。基于堆的结构特征，这种信息可以很自然的重复利用。另一方面，由于堆和顺序表的关系，一个堆和一个排序序列可以很方便地嵌入在同一个顺序表，不需要任何辅助结构。\n2 算法的实现  如果在一个连续表里存储的数据是一个大顶堆(记录之间的关系满足堆序)，按优先队列 的操作方式反复弹出堆顶元素，能够扽到一个递增序列。不难想到，这就形成了一种可行的方法，可以用于完成堆连续表中元素的排序工作。\n 基于这种技术完成排序工作，还需要解决两个问题：\n 连续表的初始元素序列通常不满足堆序。这个问题可以根据堆 中的初始建堆解决。 选出的元素存放哪里？能不能用其他空间？   实际第二个问题很好解决：随着元素弹出，堆中元素越来越少。每弹出一个元素，表的后部就会空出一个位置，正好用于存放弹出的元素。\n 具体实现代码如下： def heap_merge(lst): def sift_down(lst, e, begin, end): i, j = begin, (begin \u0026lt;\u0026lt; 1) + 1 while j \u0026lt; end: if j+1 \u0026lt; end and lst[j+1].key \u0026gt; lst[j].key: j = j+1 if e.key \u0026gt; lst[j].key: break lst[i] = lst[j] i, j = j, (j\u0026lt;\u0026lt;1)+1 lst[i] = e end = len(lst) # 建堆 for i in range(end \u0026gt;\u0026gt; 1, -1, -1): sift_down(lst, lst[i], i, end) # 循环逐个取出最大元素，将其积累的表的最后，放一个退一步 for i in range((end-1), 0, -1): e = lst[i] lst[i] = lst[0] sift_down(lst, e, 0, i) \n","id":2,"section":"posts","summary":"1 定义 堆排序是一种高效的选择排序算法。 基于堆 的概念， 该算法高效的主要原因是在堆里积累了前面所做的比较。基于堆的结构特征，这种信息可以很自然的","tags":["排序","堆排序","堆"],"title":"数据结构基础之堆排序","uri":"https://wst-casd.github.io/wst.github.io/2021/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 定义  归并是一种典型的序列操作，其工作是把两个或者更多有序的序列合并成一个有序序列。基于归并的思想也可以实现排序，成为归并排序。基本方法如下：\n 初始时，把待排序序列中的$n$个记录看成$n$个有序子序列(因为一个记录的序列总是排好序的)，每个子序列的长度均为1。 把此时子序列中的有序子序列两两归并，完成一遍后序列里的排序序列个数减半，每个子序列的长度加倍。 对加长的子序列重复场面的操作，最终得到一个长度为$n$的有序序列。  这种归并算法成为简单的二路归并排序，其中每次操作都是把其中两个有序序列合并成一个有序序列。\n下图1是一个归并排序的例子。\n 2 算法的实现  归并排序本质上是分治的思想，可以用递归和非递归的方式来分别实现。\n2.1 归并排序的非递归实现  弄清楚算法的过程，下面的问题就是如何实现这种计算过程。在这里需要一遍遍的归并，出现的一个问题是归并结果的序列放在哪里。\n 下面的讨论中使用了一种简便的处理方式，为实现归并另外开辟了一个同样大小的存储区，把一遍归并的结果放在这里。在一遍归并做完后，新表里保存着原表的所有数据。在这种情况下，可以考虑调换两个表的角色，在原表中存储下一遍归并的结果。这样来来回回做几遍，就能完成整个排序工作了。\n 显然，在这种情况下，实际上至少需要O($n$)的辅助空间。这是付出空间代价，获得实现的简便。\n 归并排序的算法分为三层实现：\n a) 最下层：实现表中相邻的一对有序序列的归并工作，将归并的结果存入另一个表中；\n b) 中间层：基于a)，实现对整个表里顺序各对有序序列的归并，完成一遍归并，各对序列的归并结果顺序存入另一个表的同位置分段；\n c) 最高层：在两个表之间来回执行操作b)，完成一遍归并后交换两个表的地位，然后在重复操作b)的工作，直至整个表里只有一个有序序列的序列。\n 一般情况下，被排序表的长度不一定是2的幂，因此需要考虑序列最后的不规则情况。\n现考虑最下面一层函数merge，它完成表中连续排放的两个有序序列的归并工作。具体的实现代码如下： def merge(lst_from, lst_to, low, mid, high): i, j, k = low, mid, low while i \u0026lt; mid and j \u0026lt; high: if lst_from[i] \u0026lt;= lst_from[j]: lst_to[k] = lst_from[i] i += 1 else: lst_to[k] = lst_from[j] j += 1 k += 1 while i \u0026lt; mid; lst_to[k] = lst_from[i] i += 1 k += 1 while j \u0026lt; high: lst_to[k] = lst_from[j] j += 1 k += 1 \n注意：上述归并算法以及下面的讨论中，对于区间均默认是左闭右开。\n函数merge_pass实现一对对分段的一遍归并，它需要知道表长度和分段长度，参数llen和slen分别表示两个长度。第一个循环处理一对对长度都为slen的分段，随后的if语句处理表最后剩下的两个或一个分段。具体代码如下： def merge_pass(lst_from, lst_to, llen, slen): i = 0 while (i+2*slen) \u0026lt; llen: merge(lst_from, lst_to, i, i+slen, i+2*slen) i += 2*slen if i + slen \u0026lt; llen: merge(lst_from, lst_to, i, i+slen, llen) else: for j in renge(i, llen): lst_to[j] = lst_from[j]\n最后是最高层的merge_sort函数，它先安排另一个同样长度的表，然后在两个表之间往复的一遍遍归并，直至完成。具体代码如下：\ndef merge_sort(lst): slen, llen = 1, len(lst) lst_to = [None]*llen while slen \u0026lt; llen: merge_pass(lst, lst_to, llen, slen) slen *= 2 merge_pass(lst_to, lst, llen, slen) slen *= 2  2.2 归并排序的递归实现  下图是归并排序递归过程的一个例子。本质上是采用分治的思想，\n  下面是代码实现 def merge(lst, low, mid, high): i, j, k = low, mid, low lst_to = [ None ]*len(lst) while i \u0026lt; mid and j \u0026lt; high: if lst[i] \u0026lt;= lst[j]: lst_to[k] = lst[i] i += 1 else: lst_to[k] = lst[j] j += 1 k += 1 while i \u0026lt; mid; lst_to[k] = lst[i] i += 1 k += 1 while j \u0026lt; high: lst_to[k] = lst[j] j += 1 k += 1 k = low while k \u0026lt; high: lst[k] = lst_to[k] k += 1 def merge_sort(lst): def merge_handle(lst, low, high): if low \u0026gt;= high: return mid = (low + high) \u0026gt;\u0026gt; 1 merge_handle(lst, low, mid) merge_handle(lst, mid, high) merge(lst, low, mid, high) mer_handle(lst, 0, len(lst)) \n3 算法的分析  首先考虑算法的时间复杂度。易见，做完第$k$遍递归后，有序子序列的长度为$2^k$。因此，完成整个排序需要做的递归遍数不会多于$log_{2}n$+1。在每遍归并中做的比较次数为O($n$)，所以，总的比较次数和移动次数都为O($n$log$n$)。\n 空间复杂度为O($n$)。\n 上述介绍的归并排序算法是稳定的，但不具有适应性，因为无论对什么样的序列都做$log_{2}n$遍递归。\n4 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":3,"section":"posts","summary":"1 定义 归并是一种典型的序列操作，其工作是把两个或者更多有序的序列合并成一个有序序列。基于归并的思想也可以实现排序，成为归并排序。基本方法如下","tags":["排序","归并排序"],"title":"数据结构基础之归并排序","uri":"https://wst-casd.github.io/wst.github.io/2021/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 定义  快速排序实现中也采用了发现逆序和交换记录位置的方法，但算法中最基本的思想还是划分，即按某种标准把待排序的序列划分为“小记录”和“大记录”两组，标准被放入了正确位置，小记录都在标准的左边，大记录都在标准的右边，然后递归对小记录序列和大记录序列进行划分，最终得到一个排序的序列。其基本过程是：\n 选择一个基准，把被排序序列中的元素按基准划分为大小两组。较小一组的在基准的前面，较大一组的记录在基准的后面，基准被放入了正确的位置。 采用同样的方式，递归地分别划分得到的这两组记录，并继续递归的划分下去。 划分总是得到越来越小的分组，如此进行下去直到每个记录组中最多一个记录时，整个序列的排序完成。  2 算法的实现 (一次)划分的实现\n 假设现在考虑一段记录，取出其中第一个记录作为标准，设其为$R$。对大小记录的安排，划分中的一般状态如图1所示。已知的小记录积累在左边，大记录积累的右边，中间是尚未检查的记录。\n  为了完成划分，还需要利用好表中空位。取出记录$R$使表左边出现了一个空位(图1b)。这时从右边开始检查，就可以利用这个空位，把发现的第一个小记录移到左边。这一迁移操作也导致了右边留下一个空位(图1c)，可供存放在左边发现的第一个大记录。下面算法中采用这种交替的工作方式。\n 算法中利用连个下标变量$i$和$j$，其初始值分别是序列中第一个元素和最后一个元素的位置。在划分过程中，它们的值交替地作为空位和下一个被检查记录的下标。取出第一个元素$R$，设其排序码为$K$，作为划分标准。\n 交替进行下面两个操作：  状态如图1b所示。从右向左逐个检查$j$一遍的记录，检查中$j$的值不断减1，直到找到第一个关键码小于$K$的记录，将其存入$i$所指的空位。注意，移动记录后$j$变成了一个空位，$i$值加1后指向下一个需要检查的记录。 状态如图1c所示。从左向右逐个检查$i$一遍的记录，检查中$i$的值不断加1，直到找到第一个关键码大于$K$的记录并将其存入$j$所指的空位。注意，移动记录后$i$变成了一个空位，$j$值减1后指向下一个需要检查的记录。此时又得到了图1b的状态，转做上面的操作。   重复交替进行上述两个操作，知道$i$不在小于$j$为止。由于第一种操作中$j$不断减少，第二中操作中$i$不断增大，划分一定能完成。 划分结束时，$i$和$j$相等，指向表中的空位。将记录$R$存入空位，一次划分完成。   一次划分完成后需要对两边的子序列按同样方式递归处理。由于要做两次递归调用，快速排序算法的执行形成了一种二叉树形式的递归调用。快速排序本质上是利用分治的思想。\n算法实现代码如下： def quick_sort(lst): def partition(lst, low, high): if low \u0026gt;= high: return i, j = low, high pivot = lst[i] while i \u0026lt; j: # 用$j$从右往左扫描找小于pivot的记录 while i \u0026lt; j and lst[j].key \u0026gt;= pivot.key: j -= 1 if i \u0026lt; j: lst[i] = lst[j] i +=1 # 用$i$从左往右扫描找大于pivot的记录 while i \u0026lt; j and lst[i].key \u0026lt;= pivot.key: i += 1 if i \u0026lt; j: lst[j] = lst[i] j -= 1 lst[i] = pivot # 将pivot放入最终位置 partition(lst, low, i-1) # 递归处理左半区间 paotition(lst, i+1, high) # 递归处理右半区间 partition(lst, 0, len(lst)-1)\n另一种简单实现\n 快速排序的实现方法也可以用很多变化。下面给出一种非常简洁的实现方式(划分方式不一样)。\n算法在执行过程中一次划分的中间状态如下图2所示。其中的$R$是作为划分标准的记录，以其关键码$K$作为分界线，将表中记录(一般而言，是表中的一个分段的记录)划分为两组。执行过程中，本分段的记录(除$R$外)顺序分为三组：小记录，大记录，未检查记录。这里用两个下标变量$i$和$j$，$i$的值总是最后一个小记录的下标，而$j$的值是第一个未处理记录的下标。每次迭代比较$K$和记录$j$的关键码，有两种情况：\n 记录$j$较大，这时，简单将$j$加1，算法又回到图2的状态； 记录$j$较小，这时需要把这个记录调到左边，做法是将$i$加1，然后交换$i$和$j$位置的记录，并将$j$加1，又恢复到图2的状态。  划分完成后，需要把$R$移到正确的位置，只需要交换它与位置$i$的记录。这时处于$R$之前的记录的关键码均小于$K$，处理$R$之后的记录的关键码均大于$K$，划分完成。下面按同样方式处理小记录分段和大记录的分段(递归)，直至排序完成。\n具体的实现代码如下： def quick_sort(lst): def partition(lst, low, high): if begin \u0026gt;= end: return pivot = lst[low] i = low for j in range(low+1, high+1): if lst[j].key \u0026lt; pivot.key: i += 1 lst[i], lst[j] = lst[j], lst[i] lst[i], lst[low] = lst[low], lst[i] partition(lst, low, i-1) # 递归处理左半区间 paotition(lst, i+1, high) # 递归处理右半区间 partition(lst, 0, len(lst)-1)\n3 算法分析  首先考虑算法的时间复杂度，设被排序序列中的记录个数为$n$。从上面的算法描述过程很容易知道：在整个快速排序的执行过程中，移动操作的次数不大于比较操作的次数，因此只需比较比较操作的次数。而比较操作的次数与划分的情况有关：\n 如果每次划分都把所处理区域划为长度基本相等的两段，很显然，只需要大约log$n$层划分，就能使最下层的每个分段记录数不超过1。而在划分一层记录的过程中，关键码比较次数不超过序列长度，综合起来可知，序列中关键码的比较次数不超过O($n$log$n$); 如果每层划分得到的两段中，总有一段为空，另一段的记录个数只比划分前少一个。在这种情况下，要使所有分段的长度不大于1，就要做$n$-1层划分。完成各层划分的比较次数从$n$-1到1。显然，这种情况下总的比较次数是O($n^2$)。例如，待排序序列已经是升序或者降序时，都会出现这种情况。  由上面的分析可知，快速排序的最坏时间复杂度是O($n^2$)。\n 抽象地看，快速排序产生的划分结构，可以看作以枢轴记录为根，以两个划分分段进一步划分的结果作为左右子树的二叉树。根据二叉树可知，$n$个结点的二叉树的平均高度是O(log$n$)。因此，快速排序的平均时间复杂度是O($n$log$n$)。\n 现在考虑快速排序的空间复杂度。从表面来看，在函数定义里只用到了$i$和$j$等几个变量。但应注意，函数partition是递归定义的，每次递归都需要再次创建这些变量。另外，为支持递归执行，解释器也需要适用运行栈的空间，这些都是为实现排序而使用的辅助空间。虽然不知道解释器为每层递归花费的具体空间量，但应该认为它是常量，与递归深度和函数调用次数无关。因此，分析前面快速排序算法的空间复杂度，最重要的问题就是递归的深度，最坏情况是O($n$)。\n 快速排序因为进行交换，稳定性很可能被打破，所以快速排序不是稳定的。从上面的分析也可以看出，快速排序不具有适应性。\n4 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":4,"section":"posts","summary":"1 定义 快速排序实现中也采用了发现逆序和交换记录位置的方法，但算法中最基本的思想还是划分，即按某种标准把待排序的序列划分为“小记录”和“大记录","tags":["排序","快速排序"],"title":"数据结构基础之快速排序","uri":"https://wst-casd.github.io/wst.github.io/2021/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 定义  交换排序基于另一种完全不同的看法：一个序列中的记录没有排序好，那么其中一定有逆序存在。如果交换所发现的逆序记录对，得到的序列更加接近排序好；通过不断的减少逆序对，最终可以得到排序序列。采用不同的确定逆序的方法和交换方法，可以得到不同的交换排序算法。\n冒泡排序\n 冒泡排序是一种典型的的通过交换元素消除逆序实现排序的方法。其中的基本操作是比较相邻记录，发现相邻的逆序对时就交换它们。通过反复比较和交换，最终完成整个算法的排序工作。显然：如果序列中每对相邻记录的顺序正确(前一个记录不大于后一个记录)，真个序列就是一个排序序列。\n下图1展示的是一个冒泡排序的排序过程，这里从左到右顺序比较一对对相邻记录，发现逆序后立即交换，然后再做下一次比较。可以看出一些情况：\n 每一遍检查可以把一个最大元素交换到位，一些较大元素右移一段，可能移动很远； 从做到右，导致小元素一次只左移一位，个别距离目标位置很远的很小元素，可能延误整个排序过程。   比较和交换导致较大记录右移，就像水中气泡起，是这种排序方法的名称额由来。\n2 算法实现  从图1中可以看出，一次完整的扫描能够把一个最大的元素移到未排序部分的最后，通过一遍遍扫描，表的最后将积累越来越多排好序的大元素。每遍扫描，这段元素增加一个，经过$n$-1变扫描，一定能完成排序。另外，每做一遍，扫描的范围可以缩短一项。综合以上的描述，下面是算法的实现： def bubble_sort(lst): for i in range(len(lst)-1): for j in range(1, len(lst)-i): if lst[j-1].key \u0026gt; lst[j].key: lst[j-1], lst[j] = lst[j], lst[j-1]\n这种实现方式有一个明显的弊端，就是不论数组是否有序，两层 for 循环都要执行一遍，而数组有序的时候，不需要进行这么多次扫描，只进行一轮判断即可。所以我们一起来看看数组有序的情况下，仅判断一轮的情况如何实现。 def bubble_sort(lst): for i in range(len(lst)-1): swapped = False # 标识这轮扫描中是否有发生交换 for j in range(1, len(lst)-i): if lst[j-1].key \u0026gt; lst[j].key: swapped = True lst[j-1], lst[j] = lst[j], lst[j-1] # 判断当前这轮扫描中是否有发生交换操作 if not swapped: break \n 上面的描述中，我们知道，序列中一些距离最终位置很远的记录可能拖累整个算法。在简单的气泡排序中，导致这种结果的主要是那些距离远的小元素。\n 要缓解这种问题，应该想办法让元素大踏步地向其最终位置移动，后面将介绍的快速排序就有这样的效果。\n 另一种简单方法是双向冒泡排序，以便把小元素快速移向左方。具体做法是一遍从左向又扫描，下一遍从右向左，交替进行。图1中的例子，用双向冒泡排序操作的过程如下图2所示。\n 双向冒泡排序的算法实现如下： def bubble_sort(lst): begin = 0 end = len(lst) - 1 while begin \u0026lt; end: swapped = False for i in range(begin, end): if lst[i].key \u0026gt; lst[i+1].key: swapped = True lst[i], lst[i+1] = lst[i+1], lst[i] if not swapped: return end -= 1 swapped = False for j in range(end, bigen, -1) if lst[j].key \u0026gt; lst[j-1],key: swapped = True lst[j], lst[j-1] = lst[j-1], lst[j] if not swpped: return begin += 1\n3 算法分析  冒泡排序的性质很清楚：最坏情况的时间复杂度为O($n^2$)，改进后的方法的最好时间复杂为O($n$)，平均时间复杂度为O($n^2$)。空间复杂度为O(1)。\n 冒泡排序相等的元素不交换，所以是稳定排序。\n 改进后的冒泡排序是具有适应性的。\n4 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":5,"section":"posts","summary":"1 定义 交换排序基于另一种完全不同的看法：一个序列中的记录没有排序好，那么其中一定有逆序存在。如果交换所发现的逆序记录对，得到的序列更加接近排","tags":["排序","冒泡排序"],"title":"数据结构基础之冒泡排序","uri":"https://wst-casd.github.io/wst.github.io/2021/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 概念  在插入排序中，每次操作处理哪个记录并不重要，关键在于把被处理记录插入到已排序序列中，因此，可以采取最方便的方式取记录，即按顺序提取。选择排序的想法与之对应，这里的重要决策是选择合适记录，只要严格按递增(每次选择最小元素)，简单地顺序排放就能完成排序工作。\n 选择排序的基本思想也很简单：\n 维护需要考虑的所有记录中最小的$i$个记录的已排序序列。 每次从剩余的未排序的记录中选择关键码最小的记录，将其放在已排序序列的后面，作为的第$i$+1个记录，使已排序序列增长。 以空序列作为排序工作的开始，直到尚未排序的序列里只剩一个元素时(它必然是最大)，只需直接将其放在已排序的记录之后，整个排序完成。   在这种基本思想下，还需要解决两个问题：第一是如何选择元素；第二是作出适当安排，尽可能利用现有序列的存储空间，避免另外安排存储。\n2 算法实现 2.1 直接选择排序  最简单的选择方法是顺序扫描序列中的元素，记住遇到的最小元素。一次扫描完毕就找到了一个最小元素。反复扫描就能完成排序工作。\n  有关排序过程中的基本状态如图1所示。在排序过程中的任何时刻，表的前段积累了一批递增的已排序好的记录，而且它们都不大于任何一个未排序的记录。下一步从未排序段中选出最小的记录，将其放在已排序记录段的后面。这样在只剩一个记录时，其关键码一定最大。\n 这里出现了一个问题：如何腾出紧跟已排序段的那个位置。直接选择排序算法中简单交换这里的元素与未排序段选出的最小记录。这个做法既把新选出的元素存放好，又填补起选走一个元素留下的空位，看起来两全其美。\n例：有关键字序列[40, 32, 70, 65, 40, 48, 28]，下面对其进行选择排序。\n 初始，整个序列无序，遍历序列可知下标6位置的关键字28最小：\n 下标为6最小关键字28的元素与下标0位置的关键字40的元素互换位置，这样得到了序列有序部分的第一个关键字28的原序，而无序部分减少一个关键字的元素：\n 遍历无序序列，可知下标1位置的关键字32最小，正好位置和无序段的第一个序列重合，不用进行交换操作：\n 遍历无序序列，可知下标4位置的关键字40最小:\n 下标4位置的最小关键字40的元素与无序段的第一个下标2位置的关机子为70的元素互换位置：\n 之后的所有操作和之前一样，在无序部分找到最小的关键字，然后与无序部分的第一个关键字交换，有序部分加一，无序部分减一：\n   直接选择排序的代码如下： def select_sort(lst): for i in range(len(lst)-1): k = i for j in range(i+1, len(lst)): if lst[j].key \u0026lt; lst[k].key: k = j if k != i: lst[i], lst[k] = lst[k], lst[i]\n2.2 提高选择的效率  选择排序比较低效，原因在于其中的顺序比较：每次选择一个元素，都要从头做一边完全的比较，在整个排序过程中过了很多重复的比较工作。\n 要想提高选择排序的效率，就需要改变选择方式。重要的是设法记录在做选择的过程中，已做过的关键码比较获得的信息。在这种基本想法下，人们研究了各种树形选择技术，设法通过沿着树中路径比较的方式选出最小元素，也就是说，利用树高度与元素个数之间的对数关系。这种想法的最重要的结果是堆排序算法。\n3 算法分析  从上面的算法过程分析可知，直接选择排序的比较次数和被排序表的初始状态无关。比较的次数总是\n1+2+$\\cdots$+($n$-1)=$n\\times(n-1)/2$ 算法的是时间复杂度为O($n^2$)。从分析也可以看出，直接选择排序没有适应性。  由于存在互换位置的操作，可能造成关键码相同的元素交换次序。造成算法不稳定。可以结合插入排序的移动元素的特点，来使的算法成为稳定的算法，即只需要子找到了最小的记录之后，依次逐个后移$k$之前那些尚未排序的元素，腾出所需的空位后把最小记录存入。具体算法实现如下：\ndef select_sort(lst): for i in range(len(lst)-1): k = i for j in range(i+1, len(lst)): if lst[j].key \u0026lt; lst[k].key: k = j if k != i: d = lst[k] while k \u0026gt; i: lst[k] = lst[k-1] k -= 1 lst[i] = d 4 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":6,"section":"posts","summary":"1 概念 在插入排序中，每次操作处理哪个记录并不重要，关键在于把被处理记录插入到已排序序列中，因此，可以采取最方便的方式取记录，即按顺序提取。选","tags":["排序","选择排序"],"title":"数据结构基础之选择排序","uri":"https://wst-casd.github.io/wst.github.io/2021/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 概念  插入排序，一般也被称作简单插入排序，它的基本思想是将一个记录插入到已经排好序的有序序列中，从而得到一个新的、记录数增加1的有序序列。\n  如图1所示，连续表的前段是已排序序列，每次考虑后段待排序序列的最左元素，即图中用$i$标识的元素，插入到左侧的有序序列。这样，当所有元素都加入到已排序序列时，完成整个序列的排序工作。\n例：假设存在一个序列[4, 3, 2, 7, 5, 4, 6]，插入排序的过程如下图2所示\n 2 插入排序的实现 2.1 顺序表的插入排序  先看顺序表的排序问题。首先要考虑已排序段的安排，放在哪里。由于未排序部分越来越小，已排序部分越来越大。可以让这两个部分共享原来的表，例如表前段是已排序的部分，不需要额外的存储。\n 在排序过程中，被排序表的状态如上图1所示，下标$i$之前的段已经从小到大排序好，从$i$开始的段尚未处理，下一步考虑位置$i$的元素$d$的插入问题，并正确完成这一工作。这样一次处理一个元素后$i$值加1，直至$i$的值超过表的右端时排序完成。\n 具体每个元素的处理也需要通过一个循环。在这个循环中，需要维持已排序元素的相对顺序，并最终确定$d$的插入位置。循环开始时取出$d$，使位置$i$为空。下标变量$j$最开始记录$i$的位置(当前的空位)，并逐步左移。每次迭代将$j-1$位置元素的关键码与$d$的关键码做比较，如果$d$的关键码较小，就把$j-1$位置的元素右移到$j$位置，并将$j$值减1(表示空位左移了)。这样在$j$到$i$之间就会是一段大于$d$的元素。反复做到位置$j$之前的元素不大于$d$时，将$d$放入空位。显然，直至$i$位置现在都是已排好序列。将$i$加1后，又回到图1的状态。\n 假设表中元素是下面定义的record类的对象： class record(object): def __init__(self, key, value): self.key = key self.value = value def __gt__(self, other): return self.key \u0026gt; other.key def __le__(self, other): return self.key \u0026lt;= other.key\n具体算法的实现如下： def insert_sort(lst): for i in range(1, len(lst)-1): d = lst[i] j = i # 反复逐个后移元素，确定插入位置 while j \u0026gt; 0 and lst[j-1].key \u0026gt; d.key: lst[j] = lst[j-1] j -= 1 lst[j] = d\n插入排序算法的变形\n 在插入排序过程中，需要检索元素的插入位置，而且是在已经排序的序列部分里检索。这提示了另一可能的方案：采用二分法查找插入位置。\n 但稍微分析可以看出，这种做法不可能从根本上改变算法的性质：虽然每次检索位置的代价降低了，但是找到位置后还是需要顺序移动元素，腾出空位将元素插入。后一操作仍可能需要限行时间。在基于二分法检索插入位置时，要保证得到的是已排序段中关键码相同的元素后面的位置，才能得到稳定的算法。\n基于递归的实现\n 从上面的描述中可以看出，对下标$i$的元素进行插入操作的前提是，原序列中下标$0, 1, \\cdots, i-1$的元素已经有序，同理对下标$i-1$的元素进行插入操作的前提是，原序列中下标$0, 1, \\cdots, i-2$的元素已经有序，\u0026hellip;，可以看出是个递归的过程。 def insert_sort(lst): def recursive_sort(lst, n): if n \u0026lt;= 1: return recuesive_sort(lst, n-1) j = n-1 d = lst[j] while j \u0026gt; 0 and lst[j-1].key \u0026gt; d.key: lst[j] = lst[j-1] j -= 1 lst[j] = d recursive_sort(lst, len(lst))\n2.2 单链表的插入排序  单链表由于只有next链接，扫描指针只能向下一个方向移动，不能从后向前查找元素。这里存在两种可能完成排序的做法：移动表中的元素或者调整结点之间的链接关系。\n基于移动元素的单链表插入排序算法 class LNode(object): def __init__(self, data, next=None): self.data = data self.next = None def insert_sort(lst): if lst.head is None: return cur = lst.next while cur is not None: d = cur.elem p = lst.head while p is not cur and p.elem \u0026lt;= d: p = p.next while p is not cur: p.elem, d = d, p.elem p = p.next cur.elem = x cur = cur.next\n基于调整链接的单链表插入排序算法 class LNode(object): def __init__(self, data, next=None): self.data = data self.next = None def insert_sort(lst): p = lst.head if p is None p.next is None: return cur = p.next p.next = None while cur is not None: p = lst.head q = None while p is not None and p.elem \u0026lt;= cur.elem: q, p = p, p.next if q is None: lst.head = cur else: q.next = cur q = cur cur = cur.next q.next = p\n3 算法分析  从上面的分析可以看出算法的空间复杂度是O(1)。\n 外层循环总是要进行$n$-1次，内存循环的执行次数与实际的情况有关。如果原序列逆序排列，则需要$n \\times (n-1)/2$次，原序列已经是排好序的话，需要$n$-1次。\n 也就是说，最坏情况下的时间复杂度是O($n^2$)，最好的情况下时间复杂度是O($n$)。\n 简单插入排序是稳定的：因为在内层循环中检索插入位置的过程中，一旦发现前面的元素与当前元素关键码相等，就不在移动元素了。\n 简单插入排序显然具有适应性。\n4 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":7,"section":"posts","summary":"1 概念 插入排序，一般也被称作简单插入排序，它的基本思想是将一个记录插入到已经排好序的有序序列中，从而得到一个新的、记录数增加1的有序序列。 如","tags":["排序","插入排序"],"title":"数据结构基础之插入排序","uri":"https://wst-casd.github.io/wst.github.io/2021/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":"1 定义  排序(Sorting)就是整理数据的序列，使其中元素按照特定顺序排列的操作。在排序的过程中，序列中的数据元素保持不变，但其排序顺序可能改变。\n定义\n 可以给排序问题一个抽象的定义：假设数据集合为$S$，集合$S$的元素上有一个序关系$\\leq$，一个排序算法sort就是从$S$的元素序列到$S'$的元素序列的映射。对$S$的任意元素序列$s$，$s'$=sort($s$)是$s$的一个排列(序列中的元素不变，其排列顺序可能调整)，使得对$s'$中任意一对相邻元素$e$和$e'$，都有$e \\leq e'$。\n 如果用$loc_s(e)$表示$e$在序列$s$中的位置，易见，在排序后的序列$s'$里，元素是按照序$\\leq$上升存放的，也就是说，$loc_{s\u0026rsquo;}(e) \\leq loc_{s\u0026rsquo;}(e\u0026rsquo;)$当且仅当$e \\leq e'$。这里的前一个“$\\leq$”表示整数(位置)的小于关系，后一个“$\\leq$”表示这一排序所用的数据集上的序。\n2 排序算法 基于比较的排序  下面主要考虑基于元素中的关键码及其比较操作的排序。\n 假设需要排序的是某种记录的序列$R_0, R_1, R_2, \\cdots, R_{n-1}$，每个记录里有一个或几个支持排序的关键码，这些关键码相对简单，存在易于判断的序关系。除此之外，在数据记录里还可以有任意多的其他成分，但它们与排序无关，因此在下面的讨论中省略。为方便讨论，假设需要考虑的总是$R_i$中的关键码$K_i$。\n 为简化讨论，下面假定按照递增排序，递减可以同理。\n内排序和外排序\n 在一个排序算法的执行过程中，如果待排序的记录全部存在内存，这种工作成为内排序。\n 当所有待排序记录不能被一次载入内存进行处理时，这样的排序就被称为外排序。外部排序通常应用在待排序记录的数量非常大的时候。归并排序以及它的变体是大多数外部排序算法的基础。外部排序通常与硬盘、CD等外部存储器（辅存）关联在一起。\n 前面说，排序工作数据集合中存在一种可用的序。由前面讨论可知，如果数据本身没有自然的序，也可以给它造一种序。最典型的方法就是设计一种hash函数，把数据集的元素映射到某个有序集，如整数集合的子集。\n基本操作、性质和评价\n 在考虑算法时，最基本的问题是其时间和空间复杂度。\n 现在要做的是数据记录排序，而且基于关键码比较，比较之后有可能要调整数据记录的位置(顺序)。根据这些情况可以确定两种最重要的基本操作：\n 比较关键码的操作，通过这中操作确定数据的顺序关系。 移动数据记录的操作，用于调整记录的位置和/或顺序。  在讨论各种排序算法时，总是以被排序序列的长度(即序列中元素的个数)作为问题规模参数$n$，讨论在完成整个排序的过程中执行上述两种操作的次数(的量级)，以此作为评价算法效率的度量(时间复杂度)。\n 在考虑内存排序算法的空间复杂度时，特别关注其空间复杂度是否是常量的。常量的空间复杂度意味着排序工作可以在原序列里完成，只需要几个简单变量作为操作中的临时存储。具有这种性质的算法称作原地排序算法。\n 除了这些具有普遍意义的性质外，排序算法也有一些与问题相关的特有性质，具体是以下两个：\n稳定性：这是排序算法的一个重要性质，稳定的算法在实际中可能更有用。\n 在做一种排序算法时，待排序序列里可能出现两个不同记录$R_i$和$R_j$(设有$0 \\leq i \u0026lt; j \\leq n-1$)的排序码相同的情况，即有$K_i=K_j$。如果某个排序算法能保证：对于待排序的序列里的任一排序码相同的记录$R_i$和$R_j$，在排序之后的序列里$R_i$和$R_j$的前后序列不变，就称这种排序算法是稳定的。\n适应性：这是排序算法的另一个很有价值的性质。\n 如果一个算法对接近有序的的序列工作的更快，就称这种算法具有适应性。\n排序算法的分类：\n 下面只是一个简单的分类：\n 插入排序 选择排序 冒泡排序 归并排序 快速排序 堆排序 计数排序 基数排序 桶排序 希尔排序 Tim排序 外部排序  3 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":8,"section":"posts","summary":"1 定义 排序(Sorting)就是整理数据的序列，使其中元素按照特定顺序排列的操作。在排序的过程中，序列中的数据元素保持不变，但其排序顺序可能","tags":["排序"],"title":"数据结构基础之排序","uri":"https://wst-casd.github.io/wst.github.io/2021/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F/","year":"2021"},{"content":" 平衡二叉排序树的基本考虑是：如果树中的每个结点的左右子树的高度差不多(\u0026ldquo;平衡\u0026rdquo;)，整个树的结构也会比较好，不会出现特别长的路径。\n1 定义 平衡二叉树（Balanced Binary Tree 或 Height-Balanced Tree）又称为AVL树，其实就是一棵平衡的二叉排序树，AVL树或者是一棵空树，或者其左右子树都是平衡的二叉排序树，且左子树和右子树的深度之差的绝对值不超过1。\n什么是平衡因子？\n 平衡二叉树上结点的 平衡因子 BF(Balanced Factor) 定义为该结点的左子树深度减去它的右子树的深度，平衡二叉树上所有结点的平衡因子只可能是 -1，0，1。\n下图1和图2，是分别2棵平衡二叉树和一棵非平衡二叉树的的例子。\n   2 平衡二叉树的实现 平衡二叉树(AVL树)也是二叉排序树，因此，在AVL树上的查询就是在普通二叉排序树上的查询，能在O(log$n$) 的时间内完成。\n 首先，把AVL树结点类的定义为二叉树结点类(详情见二叉排序树的实现 )的子类，增加一个平衡因子(bf)属性。类的类的初始化方法设置这个属性： class AVLTNode(BinTNode): def __init__(self, data): BinTNode.__init__(self, data) self.bf = 0\n AVL树是一种二叉排序树，将AVL树类定义为BSTree的子类，所有不改变结构的方法都可以继承，但实现插入和删除操作的方法需要重新定义，因为现在需要考平衡的问题，这是本类的特殊需求。 class AVLTree(BSTree): def __init__(self): BSTree.__init__(self)\n2.1 插入操作  AVL树上的插入操作，前一部分等同于普通二叉树的插入，即首先通过查询在树中找到插入位置，而后加入新结点。这时出现了新问题：原来树是平衡的，但在插入结点后可能使树中的某个局部失衡，应考虑必要的调整。\n插入后的失衡和调整  首先，应该能看到在查询插入位置的过程中，如果所有途径结点的BF值均为0，那么实际插入结点不会导致这些结点失衡，只是需要把它们的的BF值修改为1或-1，其余结点的BF值不变，整棵树也不会失衡。实际插入后，更改途径结点的BF值，操作就完成了。  如果不是上面这种情况，那么一定存在一棵包含实际插入结点的最小非平衡子树，即那棵包含新结点插入位置的，且根结点的BF非0的最小子树。如果插入新结点后这棵子树仍保持平衡，而且高度不变，那么整棵二叉排序树也将保持平衡。进一步说，如果插入新结点后的结构调整和BF值的修改都能在该子树内部的一条路径上完成，插入操作的复杂度将不超过O(log$n$)。  假设插入结点所在的最小非平衡子树的根结点为$a$，如下图3中(1)所示，其左子树较高(右子树较高的情况类似)。如果插入点在$a$的右子树(较低的子树)，插入结点后只需要调整$a$之下直至插入点的路径上所有结点的BF值(根据$a$结点的选择，这些结点的BF值原来都为0)，并将$a$的BF值修改为0。由于以$a$为根的子树的高度没变，插入和调整对其他部分没有影响，整个树保持平衡，插入操作圆满完成。\n   如果新结点插入在$a$的左子树，就会破坏$a$的平衡，如图3中(2)所示。在这种情况下，就要设法恢复结点$a$的平衡。注意，新结点插入在$a$的较高子树，也说明另一子树较低。从较高子树中调整结点到另一个子树，降低其高度，就能恢复$a$的平衡。这样调整后维持子树的高度不变，整个插入操作对子树之外部分的平衡没有任何影响。\n 下面考虑具体的恢复操作，分为四种情况处理：\n LL型调整($a$的左子树较高，新结点插入在$a$的左子树的左子树) LR型调整($a$的左子树较高，新结点插入在$a$的左子树的右子树) RR型调整($a$的右子树较高，新结点插入在$a$的右子树的右子树) RL型调整($a$的右子树较高，新结点插入在$a$的右子树的左子树)  易见，RR对应LL，RL对应LR，分别插入在$a$的外侧和内侧。在下面的讨论中，只需要关心以$a$为根的这棵子树，整棵树的其他部分没有任何变化。\nLL(RR)失衡和调整：情况如图4所示。插入操作前，$a$的以$b$为根的子树较高。由于$a$是最小非平衡子树的根，$b$的平衡因子一定为0，其两棵子树等高。注意，图中子树$A$/$B$/$C$高度相同，这棵子树的中序遍历序列为$A b B a C$，其中大写字母表示相应子树的中序遍历序列。\n 新结点插入图4中子树$A$，导致结点$a$失衡，如图4中(2)所示。在这种情况下做一个顺时针旋转，调整结点$b$和$a$的位置关系：将结点$b$作为调整后的子树的根结点，$a$作为$b$的右子结点，$b$原来的右子树作为$a$的左子树。不难看出，现在$a$的两棵子树等高，b的两棵子树也等高，且与插入前以$a$为根的子树同样高。调整完成。易见，调整后的中序遍历序列没有被破坏。\n  将LL调整实现为AVL树里的一个静态方法： @staticmethod def LL(a, b): a.left = b.right b.right = a a.bf = b.bf = 0 return b\n这里假定函数的两个参数分别为最小非平衡子树的根$a$和其左子树的根$b$，这个方法返回调整后的得到的新子树的根。\n 与之对应的是RR失衡和调整，处理方法和LL调整完全对称。两个参数分别是最小非平衡子树的根$a$和其右子树的根$b$，方法也返回新子树的根： @staticmethod def RR(a, b): a.right = b.left b.left = a a.bf = b.bf = 0 return b\n LR(RL)失衡和调整：情况如下图5所示。插入操作前，$a$的以$b$为根的左子树较高。同样，由于$a$是最小非平衡子树的根，$b$的平衡因子为0。由于新结点要插入在左子树的内侧，考虑$b$的右子结点$c$。以$c$为根的子树与$A$和$D$一样高，新结点将插入到以$c$为根的子树中。注意，由于$a$是最小非平衡子树的根，$c$的平衡因子同样为0。以$a$为根的子树的中序遍历序列是$AbBcCaD$，其中大写字母表示相应子树的中序遍历序列。\n  新结点可能插入$c$的左子树或者右子树，插入后$a$失衡，情况如图5中(2)所示。接下来的调整是把$c$提升为这棵树的根，以$b$和$a$分别作为$c$的左右子结点。根据新结点究竟插入在原来$c$的哪棵子树，$b$和$a$的平衡因子可能为0或者1/-1，无论如何都不失衡，子树的新根结点$c$的平衡因子为0。调整后的子树的高度和插入前一样高，无论新结点插入$B$还是$C$，结果序列都正确排序。\n 下面实现LR调整的静态方法，和前面LL调整一样，$a$和$b$分别为最小非平衡子树的根及其左子结点，函数返回调整后的子树的根结点。 @staticmethod def LR(a, b): c = b.right b.right, a.left = c.left, c.right c.left, c.right = b, a if c.bf == 0: a.bf = b.bf = 0 return c elif c.bf == 1: b.bf, a.bf = 0, -1 else: b.bf, a.bf = 1, 0 c.bf = 0 return c\n这里有一个特殊情况，就是插入前$b$为叶结点，$c$就是新插入的结点。这种情况也将$c$作为结果子树的根，以$b$和$a$分别作为其左子结点和右子结点。\n RL失衡和调整的情况与LR是对称的，下面是实现该调整的静态方法： @staticmethod def RL(a, b): c = b.left b.left, a.right = c.left, c.right c.left, c.right = a, b if c.bf == 0: a.bf = b.bf = 0 return c elif c.bf == 1: b.bf, a.bf = -1, 0 else: b.bf, a.bf = 0, 1 c.bf = 0 return c\n总结和分析\n 总结一下前面的讨论：插入新结点后出现失衡的情况只有上面几种，经过局部的旋转调整都可以恢复平衡。具体做法是先插入新结点，发现失衡后只需要在最小不平衡子树的根结点附近做局部调整，就可以把该子树的平衡因子变成0，而且保证这棵子树的高度与插入前相同。另外，所做的调整不会改变树中数据的排序序列。\n 由于插入结点并完成必要调整后，这棵子树与插入前在这个位置的子树高度相同，其结构变化对子树之外的其他部分毫无影响。因此，整棵二叉树中其他结点的平衡因子都不需要修改。随着整棵子树恢复平衡，整棵二叉树也恢复了平衡。\n 插入算法的操作分为几个阶段：首先找到插入位置并实际插入新结点，然后可能需要修改一些结点的平衡因子，发现失衡是做一些局部调整。这里所有的操作都是在树中的一条路径上进行的，所以AVL树插入操作的代价是O(log$n$)。\n插入操作的实现 现在考虑插入操作的具体实现，其操作过程如下：  1）查找新结点的插入位置，并在查找过程中记录遇到的最小不平衡子树的根：\n 用一个变量a记录距插入位置最近的平衡因子非0的结点，由于可能需要修改这棵子树，再次过程中用另外一个变量pa记录a的父结点。 如果不存在这种结点，需要考虑的a就是树根。 如果在新结点插入后出现失衡，a就是失衡位置。 实际插入新结点。  2）修改从a的子结点到新结点的路径上的各结点的平衡因子：\n 根据a的定义，这段结点原来的平衡因子都是0。 插入后用一个扫描变量p从a的子结点开始遍历，如果新结点插入在p的左子树，就把p的的BF改为1，否则改为-1。  3）检查以a为根的子树是否失衡，失衡时做调整：\n 如果a.bf == 0，插入后不会失衡，简单修改平衡因子结束。 如果a.bf == 1 且新结点插入在a的左子树，就出现了失衡。  新结点在a的左子结点的左子树时做LL调整。 新结点在a的左子结点的右子树时做LR调整。   如果a.bf == -1 且新结点插入在a的右子树，就出现了失衡。  新结点在a的右子结点的右子树时做LL调整。 新结点在a的右子结点的左子树时做RL调整。    4）连接好调整后的子树，它可能应该作为整棵树的根，或作为a原来的父结点的相应方向的子结点。\n下面是插入操作的具体实现代码： @staticmethod def insert(self, key, value): a = p = self._root if a is None: self._root = AVLNode(Assoc(key, value)) return pa = q = None # 确定插入位置，并记录最小非平衡子树位置 # q为插入点的父结点，a为最小非平衡子树的根结点，pa为a的父亲 while p: if key == p.data.key: p.data.value = value return if p.bf != 0: pa, a = q, p q = p if key \u0026lt; p.data.key: p = p.left else: p = p.right node = AVLNode(Assoc(key, value)) # 插入结点 if key \u0026lt; q.data.key: q.left = node else: q.right = node # 判断是插入到了a这棵子树的左子树还是右子树 if key \u0026lt; a.data.key: p = b = a.left d = 1 else: p = b = a.right d = -1 # b为a的子结点，修改b到新结点路径上的个结点的BF值 while p != node: if key \u0026lt; p.data.key: p.bf = 1 p = p.left else: p.bf = -1 p = p.right if a.bf == 0: a.bf = d return if a.bf == -d: a.bf = 0 return if d == 1: if b.bf == 1: b = AVLTree.LL(a, b) else: b = AVLTree.LR(a, b) else: if b.bf == -1: b = AVLTree.RR(a, b) else: b = AVLTree.RL(a, b) if not pa: self._root = b elif pa.left == a: pa.left = b else: pa.right = b\n3 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":9,"section":"posts","summary":"平衡二叉排序树的基本考虑是：如果树中的每个结点的左右子树的高度差不多(\u0026ldquo;平衡\u0026rdquo;)，整个树的结构也会比较好，不会出现特","tags":["树","平衡二叉树"],"title":"数据结构基础之平衡二叉树","uri":"https://wst-casd.github.io/wst.github.io/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","year":"2021"},{"content":"1 二叉排序树 1.1 定义  二叉排序树(Binary Sort Tree)，又称二叉查找树(Binary Search Tree)，是一种在结点里存储数据的二叉树。它或者是一棵空树，或者是具有以下特征的树：\n 若它的左子树不空，那么它的左子树的所有结点的值均小于根结点的值； 若它的右子树不空，那么它的右子树的所有结点的值均大于跟结点的值； 左子树与右子树也分别为二叉排序树。  显然，二叉排序树也是一种递归结构，其左右子树具有与整棵树同样的结构。\n 例1，考虑关键码的系列为[57, 89, 96, 36, 65, 43, 52, 7, 18, 60, 74]. 如下图1 是一棵合理的二叉排序树。\n 1.2 性质  性质 一棵结点中存储着关键码(数据)的二叉树是二叉排序树，当且仅当通过中序遍历这棵二叉树得到的关键码序列是一个递增序列。\n2 二叉排序树的实现  实现二叉排序树最关键的操作是数据项的插入，删除和查询。其中，插入和删除操作通常都要修改树的结构。\n2.1 BST的插入  二叉排序树的插入，易见，对插入操作的基本要求是能够把新数据项加入(二叉排序树)中，并维持二叉排序树的完整性，包括关键码的顺序要求。对于任意一个待插入的数据项都是插入在二叉排序树的叶子结点，问题的关键是找到加入新结点的正确位置，并将新结点正确连接到树中。\n 插入操作中一个重要问题：如果遇到关键码相同的数据项怎么处理？在下面的处理中，总用新值替换关键码的已有关联值，这样会保证二叉排序中不会出现关键码重复的项。\n 查找位置就是用数据项的关键码来检索，\n 如果二叉树为空，就直接建立一个包含新建一个包含新关键码和关联值的树根结点； 否则，搜索新结点的插入位置，沿子结点关系向下：  遇到应该走向左子树而左子树为空，或者应该走向右子树而右子树为空时，就是找到了新数据项的插入位置，构造新结点并完成实际插入。 遇到结点里的关键码等于被检索关键码，直接替换关键值并结束。     下图是图1所示例二叉排序树的创建过程：\n   2.2 BST的查找  由于二叉排序树(及其子树)的根中保存的数据总是把树中的数据划分为较大和较小的两组，用需要查询的关键码与之比较，就可以知道下一步应该到哪棵子树去查询(这一过程是递归的)。\n 查询过程很清晰，就是根据被查询关键码与当前结点关键码的比较情况，决定是向左走还是向右走。遇到要查询关键码时成功结束，返回关键码的关联值；在无路可走时失败结束。\n2.3 BST的删除  假设已经确定应该删除结点 $q$，它是其父结点 $p$ 的左子结点(为 $p$ 的右子结点的情况类似)，这时有两种情况：\n $q$ 是叶结点，这时只需要将 $p$ 到 $q$ 的引用置为None，删除就完成了。     $q$ 不是叶结点，那么就不能简单删除，需要把 $q$ 的子树连接到删除 $q$ 以后的树中，而且要宝成关键码的顺序。此时可分为三种情况：\n 如果 $q$ 没有左子树，有右子树，此时只需要把 $q$ 的右子树直接改作其父结点 $p$ 的左子树;    如果 $q$ 有左子树，没有右子树，此时只需要把 $q$ 的左子树直接改作其父结点 $p$ 的左子树；    如果 $q$ 既有左子树，又有右子树，此时先找到 $q$ 的左子树的最右结点，设为 $r$，显然它没有右子树。用 $q$ 的左子树作为 $p$ 的左子结点，并将 $q$ 的右子树作为 $r$ 的右子树。     注： 以上三种情况中，第2种和第3种实际上也可以合并成一种。\n2.4 BST的实现代码 class Assoc(object): def __init__(self, key, value): self.key = key self.value = value def __lt__(self, other): return self.key \u0026lt; other.key def __le__(self, other): return self.key \u0026lt;= other.key def __str__(self): return f\u0026#39;Assoc({self.key}, {self.value})\u0026#39; class BinTNode(object): def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right class BSTree(object): def __init__(self): self._root = None def is_empty(self): return not self._root def search(self, key): cur = self._root while not cur: entry = cur.data if key \u0026lt; entry.key: cur = cur.left elif key \u0026gt; entry.key: cur = cur.right else: return entry.value return None def insert(self, key, value): if self.is_empty(): self._root = BinTNode(Assoc(key, value)) return cur = self._root while True: entry = cur.data if key \u0026lt; entry.key: if not cur.left: cur.left = BinTNode(Assoc(key, value)) return cur = cur.left elif key \u0026gt; entry.key: if not cur.right: cur.right = BinTNode(Assoc(key, value)) return cur = cur.right else: cur.data.value = value return def values(self): cur, stack = self._root, SStack() while cur or not stack.is_empty(): if cur: stack.push(cur) if cur.left: cur = cur.left else: cur = None else: cur = stack.pop() yield cur.data.value if cur.right: cur = cur.right else: cur = None def entries(self): if cur: stack.push(cur) if cur.left: cur = cur.left else: cur = None else: cur = stack.pop() yield cur.data.key, cur.data.value if cur.right: cur = cur.right else: cur = None def delete(self, key): p, q = None, self._root if not q: return while q and key != q.data.key: p = q if key \u0026lt; q.data.key: q = q.left else: q = q.right if not q: return # q.left is None if not q.left: if p is None: self._root = q.right elif q is p.left: p.left = q.right else: # q is p.right p.right = q.right return # q.left is not None and q.right is None if q.left and not q.right: if p is None: self._root = q.right elif q is p.left: p.left = q.left else: # q is p.right p.right = q.left return r = q.left while r.right: r = r.right r.right = q.right if p is None: self._root = q.left elif q is p.left: p.left = q.left else: # q is p.right p.right = q.left def build_bst(entries): bst = BSTree() for k, v in entries: bst.insert(k, v) return bst 3 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":10,"section":"posts","summary":"1 二叉排序树 1.1 定义 二叉排序树(Binary Sort Tree)，又称二叉查找树(Binary Search Tree)，是一种在结点里存储数据的二叉树。它或者是一","tags":["树","二叉树","二叉排序树"],"title":"数据结构基础之二叉排序树","uri":"https://wst-casd.github.io/wst.github.io/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","year":"2021"},{"content":"1 概念  队列 的特点是先入先出，下图是队列的一个例子：\n   优先队列 的特点是存入其中的每项数据都另外附一个数值，表示这个项的优先程度，称为其优先级。优先队列保证，在任何时候访问或者弹出的，总是当时在这个结构里保存的所有元素中优先级最高的。如果该元素不弹出，再次访问还是得到它。在一些情景中，可能出现不同元素具有相同优先级的情况。如果不止一个元素的优先级最高，优先队列将保证访问或弹出其中一个，具体是哪一个 元素由内部实现确定。\n 抽象的看，需要缓存的是一个有序集$S=(D, \\le)$的元素，这里的\u0026quot;$\\le$\u0026quot;是集合$D$上的一个全序(非严格的)，表示元素的优先关系。优先队列要求保证\u0026quot;最优先元素先出\u0026rdquo;。\n 比如，又一个最大优先队列，它的最大元素是8，那么虽然元素8并不是队首元素，但出队的时候仍然让元素8首先出队：\n  优先队列的操作也很简单，应该包含：\n 创建，判断空（还可以有清空内容，确定当前元素个数等） 插入元素，访问和删除优先队列里（当前最优先）的元素  2 优先队列的实现 2.1 基于线性表的实现  考虑一种简单方法：基于连续表技术实现优先队列。数据项在连续表里的存储顺序可用于表示数据之间的某种顺序关系。对于优先队列，这个顺序可用于表示优先级关系。在存入数据时，保证表中元素始终按照优先顺序排列(作为一种数据不变式)，任何时候都可以直接取到当时表里最优先的元素。采用有组织的元素存放方式，存入元素的操作比较麻烦，效率可能较低，但访问和弹出比较方便。\n基于list实现优先队列\n 在下面的实现中，假定需要存储的元素用\u0026quot;$\\le$\u0026quot;比较优先级，值较小的元素优先级更高。\nclass PrioQueueError(ValueError): pass class PrioQueue(object): def __init__(self, elist): self._elems = list(elist) self._elems.sort(reverse=True) def enqueue(self, e): e = len(self._elems) - 1 while i \u0026gt;= 0: if self._elems[i] \u0026lt;= e: i -= 1 else: break; self._elems.insert(i+1, e) def is_empty(self): return not self._elems def peek(self): if self.is_empty(): raise PrioQueueError(\u0026#39;in peek\u0026#39;) return self._elems[-1] def dequeue(self): if self.is_empty(): raise PrioQueueError(\u0026#39;in dequeue\u0026#39;) return self._elems.pop()  对连续表实现的分析\n 各操作的效率(复杂度)都很清晰：插入元素是O(n), 其他操作都是O(1)操作。\n 采用线性结构按序插入操作效率低，其根源就是需要沿着表顺序检索插入位置。表长度是$n$, 检索(和最终插入)必然需要O($n$)的时间。这说明，只要元素按优先级顺序线性排列，就无法避免线性复杂性问题。不改变数据的线性顺序逻辑方式，就不可能突破O($n$)的复杂度限制。\n 一般而言，确定最优先元素并不需要与所有其他元素比较。利用树状结构的祖先/孩子，又可能得到更好的操作效率。想在优先队列的实现中利用树形结构的优势，还需要解决一个问题：如何在反复插入和删除元素的过程中，持续保持树形结构的特点和操作效率。堆是一种很好的树形结构用来实现优先队列。\n2.2 基于堆的实现 class PrioQueueError(ValueError): pass class PrioQueue_Heap(object): def __init__(self, elist): self._elems = list(elist) if elist: self.__build_heap() def enqueue(self, e): self._elems.append(None) self.__sift_up(e, len(self._elems)-1) def is_empty(self): return not self._elems def peek(self): if self.is_empty(): raise PrioQueueError(\u0026#39;in top\u0026#39;) return self._elems[0] def dequeue(self): if self.is_empty(): raise PrioQueueError(\u0026#39;in deheap\u0026#39;) e0 = self._elems[0] e = self._elems.pop() if self.is_empty(): self.__sift_down(e, 0, len(self._elems)) def __sift_up(self, e, end): parent, cur = (end-1) \u0026gt;\u0026gt; 1, end while cur \u0026gt; 0 and self._elems[parent] \u0026gt; e: self._elems[cur] = self._elems[parent] cur, parent = parent, (parent-1) \u0026gt;\u0026gt; 1 self._elems[cur] = e def __sift_down(self, e, begin, end): cur, child = begin, (begin \u0026lt;\u0026lt; 1) + 1 while child \u0026lt; end: if child+1 \u0026lt; end and self._elems[child] \u0026gt; self._elems[child+1]: child += 1 if e \u0026lt; self._elems[child]: break self._elems[cur] = self._elems[child] cur, child = child, (child \u0026lt;\u0026lt; 1)+1 self._elems[cur] = e def __build_heap(self): end = len(self._elems) for i in range(end \u0026gt;\u0026gt; 1, -1, -1): self.__sift_down(self._elems[i], i, end) 3 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n[2] 漫画：什么是优先队列？\n[3] 漫画：什么是二叉堆？\n","id":11,"section":"posts","summary":"1 概念 队列 的特点是先入先出，下图是队列的一个例子： 优先队列 的特点是存入其中的每项数据都另外附一个数值，表示这个项的优先程度，称为其优先级。优","tags":["堆","优先队列"],"title":"数据结构基础之优先队列","uri":"https://wst-casd.github.io/wst.github.io/2021/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","year":"2021"},{"content":"1 堆及其性质  堆 本质上是结点里存储数据的完全二叉树，但是堆中数据的存储要满足一种特殊的堆序：任一个结点所存储的数据先于或等于其子结点(如果存在)里的数据。\n 根据堆的定义，可以看出：\n  在一个堆中，从树根到任何一个叶结点的路径上，各结点所存的数据按规定的优先关系(非严格)递减。\n  堆中最优先的元素必定位于二叉树的根结点里(堆顶)，O(1)时间就能得到。\n  位于树中不同路径上的元素，这里不关心其顺序关系。\n  小顶堆：如果所要求的序是小元素优先，构造出来的堆就称为小顶堆，堆中每个结点的数据均小于或等于其子结点的数据。\n大顶堆：如果所要求的序是大元素优先，构造出来的堆就称为大顶堆，堆中每个结点的数据均大于或等于其子结点的数据。\n下图是一个大顶堆的例子：\n  从树中介绍的完全二叉树的性质可知：一棵完全二叉树可以存入一个连续的线性结构(例如连续表)。因此，一个堆也可以自然地存入一个连续表，通过下标就能方便地找到树中任一结点的父结点/子结点。\n 堆和完全二叉树还有以下几个重要的性质：\n Q1: 在一个堆的最后加上一个元素(在连续表的最后加上一个元素)，整个结构还是可以看作是一个完全二叉树，但它未必是堆(最后元素未必满足堆序)。 Q2: 一个堆去掉堆顶(表中位置0的原序)，其余元素形成两个“子堆”，完全二叉树的子结点/父结点下标计算规则仍然适用，堆序在路径上仍然存在。 Q3: 给由Q2得到的表(两个子堆)加入一个根元素(存入位置0)，得到的结点序列又可看作完全二叉树，但它未必是堆(根结点未必满足堆序)。 Q4: 去掉一个堆中最后的元素(最下层的最后结点，也就是对应的连续表里的最后一个元素)，剩下的元素仍构成一个堆。  2 堆的实现  堆的主要操作是插入，删除和构建堆。\n注意：以下介绍以小顶堆为例，大顶堆同理。\n2.1 插入元素和向上筛选  首先，考虑向堆中插入元素的操作。根据性质Q1，在一个堆的最后加入一个元素，得到的结果还是完全二叉树，但是不一定是堆。为把这样的完全二叉树恢复成堆，只需要做一次向上筛选。\n 向上筛选的方法：不断用新加入的元素(设是e)与其父结点的数据比较，如果e较小就交换两者的位置。这一操作一直做到e的父结点的数据小于等于e时，或者e已经到达根结点为止。这时经过e的所有路径上的元素满足所需顺序，其余路径仍保持有序，因此这棵完全二叉树满足堆序，这个结构已恢复为一个堆。这样就得到堆的插入操作：\n 把新元素放入到(连续表里)已有元素之后，然后执行一次向上筛选。 向上筛选操作中，比较和交换的次数不会超过二叉树中最长路径的长度。根据完全二叉树的性质，加入元素操作可以在O($\\log_2n$)时间内完成。  下面是一个小顶堆插入的例子。在图所示的堆中插入一个新结点，值为1\n 这时候，我们让节点1与它的父节点6做比较，如果1小于6，则让新节点“上浮”，和父节点交换位置。  继续用节点1和父节点3做比较，如果1小于3，则让新节点继续“上浮”。  继续比较，最终让新节点1上浮到了堆顶位置。  2.2 弹出元素和向下筛选  由于堆顶元素最小，应该弹出的元素就是它。但弹出堆顶元素后，剩下的元素已经不再是堆。根据性质Q2，剩余元素可以看作两个“子堆”。根据Q3只需要填补一个堆顶元素就可以将它们做成一棵完全二叉树。根据Q4，从原堆的最后取下一个元素，其余元素仍然是堆。把这个元素放在堆顶就得到了一棵完全二叉树，它比弹出前的堆少一个元素，而且除了堆顶可能不满足堆序外，其余元素都满足堆序。下面需要设法把结构重新恢复成一个堆。\n 在这种情况下恢复堆的操作称作向下筛选：设两个子堆$A$和$B$加上根元素$e$构成一棵完全二叉树，在需要把它们做成一个堆，操作步骤是：\n 用$e$与$A$，$B$两个“子堆”的堆顶元素比较，最小者作为整个堆的顶。  若$e$不是最小，最小的必为$A$和$B$的根。设$A$的根最小，将其移到堆顶，相当于删去了$A$的顶元素。 把$e$放到去掉堆顶的$A$，这是规模更小的同一问题。 $B$的根最小的情况可以同样处理。   如果某次比较中$e$最小，以它为顶的局部树已经成为堆，整个结构也成为堆。 或者$e$已经落到底，这时它自身就是一个堆，整个结构也成为堆。 到达最后两种情况，重新构造堆的工作就完成了。   总结一下堆弹出操作的实现，分为三大步骤：\n 弹出当时的堆顶。 从堆最后取一个元素作为完全二叉树的根。 执行一次向下筛选。（O($\\log_2n$)的时间复杂度）  下面是一个小顶堆删除的例子。在图所示的堆中删除堆顶结点2\n 这时候，为了维持完全二叉树的结构，把堆的最后一个节点10补到原本堆顶的位置。  接下来我们让移动到堆顶的节点10和它的左右孩子进行比较，如果左右孩子中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。  继续让节点10和它的左右孩子做比较，左右孩子中最小的是节点7，由于10大于7，让节点10继续“下沉”。  这样一来，堆重新得到了调整。 2.3 构建堆  基于一个已有的list建立初始堆。做法基于这样一个事实：一个序列已经是堆；如果元素位置合适，在表里已有的两个“子堆”上加一个元素，通过一次向下筛选，就可以把这部分元素调整为一个更大的子堆。\n 把初始的表看作一棵完全二叉树，从下标end//2的位置开始，后面表元素都是二叉树的叶结点，也就是说，它们中的每一个已是一个堆，也就是从完全二叉树最下最右分支结点开始，向左一个个建堆，然后再到上一层建堆，直至整个表建成一个堆。\n2.4 堆的实现 class HeapError(ValueError): pass class Heap(object): def __init__(self, elist): self._elems = list(elist) if elist: self.__build_heap() def enheap(self, e): self._elems.append(None) self.__sift_up(e, len(self._elems)-1) def is_empty(self): return not self._elems def top(self): if self.is_empty(): raise HeapError(\u0026#39;in top\u0026#39;) return self._elems[0] def deheap(self): if self.is_empty(): raise HeapError(\u0026#39;in deheap\u0026#39;) e0 = self._elems[0] e = self._elems.pop() if self.is_empty(): self.__sift_down(e, 0, len(self._elems)) def __sift_up(self, e, end): parent, cur = (end-1) \u0026gt;\u0026gt; 1, end while cur \u0026gt; 0 and self._elems[parent] \u0026gt; e: self._elems[cur] = self._elems[parent] cur, parent = parent, (parent-1) \u0026gt;\u0026gt; 1 self._elems[cur] = e def __sift_down(self, e, begin, end): cur, child = begin, (begin \u0026lt;\u0026lt; 1) + 1 while child \u0026lt; end: if child+1 \u0026lt; end and self._elems[child] \u0026gt; self._elems[child+1]: child += 1 if e \u0026lt; self._elems[child]: break self._elems[cur] = self._elems[child] cur, child = child, (child \u0026lt;\u0026lt; 1)+1 self._elems[cur] = e def __build_heap(self): end = len(self._elems) for i in range(end \u0026gt;\u0026gt; 1, -1, -1): self.__sift_down(self._elems[i], i, end) 3 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n[2] 漫画：什么是二叉堆？\n","id":12,"section":"posts","summary":"1 堆及其性质 堆 本质上是结点里存储数据的完全二叉树，但是堆中数据的存储要满足一种特殊的堆序：任一个结点所存储的数据先于或等于其子结点(如果存在","tags":["树","二叉树","完全二叉树","堆"],"title":"数据结构基础之堆","uri":"https://wst-casd.github.io/wst.github.io/2021/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A0%86/","year":"2021"},{"content":"1 树  树(tree)是一种数据结构，是由有限个($n$个($n\u0026gt;0$))结点组成的具有层次关系的集合，它具有以下的特点：\n  一个结构如果不空，其中就存在着唯一的起始结点，称为树根(root)。\n  按结构的连接关系，树根外的其余结点有且只有一个前驱，同时，一个结点可以有0个或者多个后继。\n  结构里的所有结点都在树根结点通过后继关系可达的结点集合里。\n  结点之间的联系不会形成循环关系。\n  从这种结构里的任意两个结点出发，通过后继关系可达的两个结点集合，或者互不相交，或者一个集合是另一个集合的子集。\n  2 二叉树  二叉树是一种最简单的树形结构，其特点是树中每个结点至多能关联到两个后继结点。另外一个特点是一个结点关联的后继结点明确地分为左右，或为其左孩子，或为其右孩子。\n2.1 定义  二叉树是结点的有穷集合。这个集合或者是空集，或着其中有一个称为根结点的特殊结点，其余结点分属两棵不相交的二叉树， 这两棵二叉树分别是原根结点的左子树和右子树。\n2.2 一些概念  不包含任何结点的二叉树称为空树；只包含一个结点的二叉树是一棵单点树；一般而言，一棵二叉树可以包含任意(但有穷多)个结点。\n 一棵二叉树的根结点称为该树的子树根结点的父结点；与之对应，子树的根结点称为二叉树树根结点的子结点。注意，父结点和子结点是相对的概念。\n 可认为从父结点到子结点有一条连线，称为从父结点到子结点的边。注意，这种边有方向，形成一种单方向的父结点/子结点关系(父子关系)。另外，父结点相同的两个结点互称兄弟结点。易见，一棵二叉树(或其中子树)的根结点$r$是这棵树中所有其他结点的祖先结点，而这些结点都是$r$的子孙结点。\n 在二叉树里有些结点的两棵子树都是空，没有子结点。这种结点称为树叶(结点)。树中其余结点称为分支结点。注意：分支结点可以只有一个分支(一个子结点)。对于二叉树，只有一个分支时必须说明它是其左分支还是右分支。\n 一个结点的子结点个数称为该结点的度数。显然，二叉树中叶子结点的度数为0，分支结点的度数可以为1或者2。\n路径，结点的层和树的高度\n 根据祖先结点和子孙结点的定义，从一个祖先结点到其任何子孙结点都存在一系列的边，形成从前者到后者的联系。这样一系列首尾相连的边称为树中的一条路径，路径中边的数目称为该路径的长度。统一起见，认为从每个结点到其自身有一条长度为0的路径。\n 显然，从一棵二叉树的根结点到该树中的任一结点都有路径，而且路径唯一。对二叉树的任意子树也有同样的结论。\n 二叉树是一种层次结构。将其树根看作最高层元素，如果有子结点，其子结点看作下一层元素。约定二叉树根的层数为0。对于$k$层的结点，其子结点是$k+1$层的元素。如此下去，二叉树的所有结点可以按这种关系分为一层层的元素。易知：从树根到树中任一结点的路径长度就是该结点所在的层数，也称为该结点的层数。\n 一棵二叉树的高度(深度)是树中结点的最大层数(也就是这棵树里的最长路径的长度)。树的高度是二叉树的整体性质，只有根结点的树高度为0。\n2.3 二叉树的性质  二叉树有很多非常有用的性质，现在讨论其中一些性质。作为数据结构，二叉树最重要的性质就是树的高度和树中可以容纳的最大结点个数之间的关系。\n 性质 1 在非空二叉树中第$i$层中至多有$2^i$个结点($i\\geq0$)\n 性质 2 高度为$h$的二叉树至多有$2^{h+1}-1$个结点($h\\geq0$)\n 性质 3 对于任何非空二叉树 $T$，如果其叶结点的个数为$n_0$，度数为2的结点个数为$n_2$，那么$n_0=n_2+1$\n满二叉树，扩充二叉树\n 满二叉树：如果二叉树中所有分支结点的度数都是2，则称它为一棵满二叉树。\n  扩充二叉树： 对二叉树 $T$，加入足够多的新叶结点，使 $T$ 的原有结点都变成度数为2的分支结点，得到的二叉树称为 $T$ 的扩充二叉树。扩充二叉树中新增的结点称为其外部结点。空树的扩充二叉树约定为空树。\n完全二叉树\n 对于一棵高度为$h$的二叉树，如果其第$0$层至第$h-1$层的结点都满(也就是说，对所有$0\\leq i \\leq{h-1}$，第$i$层有$2^i$个结点)，如果最下一层的结点不满，但所有结点在最左边连续排列，空位都在右边，这样的二叉树就是一棵完全二叉树。\n  性质 4 $n$个结点的完全二叉树高度$h=\\lfloor \\log_2n\\rfloor$，即为不大于$\\log_2n$的最大整数。\n 性质 5 (完全二叉树)如果$n$个结点的完全二叉树的结点按层次并按从左往右的顺序从0开始编号，对任一结点$i(0\\leq i \\leq{n-1})$都有：\n 1) 序号为$0$的结点是根。\n 2) 对于$i\u0026gt;0$，其父结点的编号为$(i-1)/2$。\n 3) 对于$ 2\\times i+1 \u0026lt; n$，其左子结点序号为$2 \\times i+1$，否则它无左子结点。\n 4) 对于$ 2\\times i+2 \u0026lt; n$，其右子结点序号为$2 \\times i+2$，否则它无右子结点。\n3 抽象数据类型  下面是一个基于的二叉树抽象数据类型的定义： ADT BinTree: BinTree(self, data, left, right) # 创建操作，创建一个新二叉树 is_empty(self) # 判断self是否为一个空二叉树 num_nodes(self) # 求二叉树的结点个数 data(self) # 获取二叉树的根结点的数据 left(self) # 获取二叉树的左子树 right(self) # 获取二叉树的右子树 set_left(self, btree) # 用btree取代原来的左子树 set_right(self, btree) # 用btree取代原来的右子树 traversal(self) # 删除栈里最后压入的元素，并将其返回 forall(self) # 取得栈顶的元素\n4 二叉树的遍历  二叉树的结构比较复杂，因此，系统化遍历有多种可能的方式，下面将讨论几种不同的算法。遍历二叉树就像前面讨论过的状态搜索，以根作为起点，存在两种基本方式：\n 深度优先遍历：顺着一条路径尽可能向前搜索，必要时回溯。 广度优先遍历：在所有路径上齐头并进。  深度优先遍历\n 按深度优先方法遍历一个二叉树，需要做三件事：遍历左子树，遍历右子树和访问根结点(有可能需要操作其中的数据)。\n  选择这三项的不同执行顺序，就可以得到三种常见的遍历顺序：\n 先序遍历(按照DLR顺序) 中序遍历(按照LDR) 后序遍历(按照LRD)  由于二叉树的子树也是二叉树，将一种具体的遍历顺序继续运用到子树的遍历中，就形成了一种遍历二叉树的统一方法。\n广度优先遍历\n 现在考虑按宽度优先遍历二叉树。如前所述，宽度优先是按路径长度由近到远地访问结点。对二叉树做这种遍历，也就是按二叉树的层次吃逐层访问树中各结点。与状态空间搜索的情况一样，这种遍历不能写成递归过程。\n 在宽度优先遍历中只规定了逐层访问，并没有规定同一层结点的访问顺序。但从算法的角度看，必须规定一个顺序，常见的是每一层里都从左到右逐个访问。实现这个算法需要一个队列 ( 数据结构基础之队列 ) 作为缓存。\n5 二叉树的实现 5.1 二叉树的list实现  二叉树是递归结构，Python的list也是递归结构。基于list类型很容易实现二叉树，例如采用下面的设计：\n 空树采用None表示 非空二叉树用包含三个元素的表 [$d, l, r$] 表示，其中  $d$表示存在根结点的元素 $l$和$r$是两棵子树，采用与整个二叉树同样的list表示    例如下面是一棵二叉树的list表示：\n [\u0026lsquo;A\u0026rsquo;, [\u0026lsquo;B\u0026rsquo;, None, None],\n[\u0026lsquo;C\u0026rsquo;, [\u0026lsquo;D\u0026rsquo;, [\u0026lsquo;F\u0026rsquo;, None, None],\n[\u0026lsquo;G\u0026rsquo;, None, None]],\n[\u0026lsquo;E\u0026rsquo;, [\u0026lsquo;H\u0026rsquo;, None, None],\n[\u0026lsquo;I\u0026rsquo;, None, None]]]]\n   相关的二叉树的实现和操作都很简单。下面是实现基本操作的一组函数定义： def BinTree(data, left=None, right=None): return [data, left, right] def is_empty_BinTree(btree): return btree is None def root(btree): return btree[0] def left(btree): btree[1] def left(btree): btree[2] def set_root(btree, data): btree[0] = data def set_left(btree, left): btree[1] = left def set_right(btree, right): btree[2] = right\n注意： 以上代码实现，并没有考虑参数合法性问题。\n 基于上述构造函数的嵌套调用，可以做出任意复杂的二叉树，例如：\n t1 = BinTree(2, BinTree(4), BinTree(8))\n这相当于写：t1 = [2, [4, None, None], [8, None, None]]\n 可以修改二叉树中的任何部分，例如： set_left(left(t1), BinTree(5))\n其中把t1的左子树的左子树换成了BinTree(5), 使t1的值变成：\n [2, [4, [5, None, None], None], [8, None, None]]\n5.2 二叉树的类实现  二叉树的类实现 class BinTree(object): def __init__(self, data=None, left=None, right=None): self._data = data self._left = left self._right = right def is_empty(self): return not self._data def root(self): return self def left_child(self): return self._left def right_child(self): return self._right def set_left(self, left_node): self._left = left_node def set_right(self, right_node): self._right = right_node def count_BinTNodes(self): if self.is_empty(): return 0 count = 1 if self._left: count += self._left.count_BinTNodes() if self._right: count += self._right.count_BinTNodes() return count def sum_BinTNodes(self): if self.is_empty(): return 0 sum = self._data if self._left: cosumunt += self._left.sum_BinTNodes() if self._right: sum += self._right.sum_BinTNodes() return sum # 先序遍历二叉树(递归实现） def pre_order(self, proc): if self.is_empty(): return proc(self._data) if self._left: self._left.pre_order(proc) if self._right: self._right.pre_order(proc) # 中序遍历二叉树(递归实现） def middle_order(self, proc): if self.is_empty(): return if self._left: self._left.middle_order(proc) proc(self._data) if self._right: slef._right.middle_order(proc) # 后序遍历二叉树(递归实现） def post_order(self, proc): if self.is_empty(): return if self._left: self._left.post_order(proc) if self._right: slef._right.post_order(proc) proc(self._data) def pre_order_nonrec(self, proc): cur = self stack = SStack() while cur._data: proc(cur._data) if cur._left: if cur._right: stack.push(cur._right) cur = cur._left elif cur._right: cur = cur._right elif not stack.is_empty(): cur = stack.pop() else: cur = BinTree() def middle_order_nonrec(self): cur = self stack = SStack() while cur._data or not stack.is_empty(): if cur._data: stack.push(cur) if cur._left: cur = cur._left else: cur = BinTree() else: cur = stack.pop() proc(cur._data) if cur._right: cur = cur._right else: cur = BinTree() def post_order_nonrec(self, proc) cur = self stack = SStack() stack.push(cur) while cur._data or not stack.is_empty(): if cur._data: stack.push(cur) if cur._left: cur = cur._left elif cur._right: cur = cur._right else: cur = BinTree() else: cur = stack.pop() proc(cur._data) if not stack.is_empty() and cur == stack.top()._left and stack.top()._right: cur = stack.top()._right else: cur = BinTree() def level_order(self, proc): queue = Squeue() if self.is_empty(): return queue.enqueue(self) while not queue.is_empty(): cur = queue.dequeue() proc(cur._data) if cur._left: queue.enqueue(cur._left) if cur._right: queue.enqueue(cur._right)\n 二叉树遍历的非递归实现中，利用了栈 (数据结构基础之栈)或者队列 (数据结构基础之队列)这种缓存结构。\n非递归的后根序遍历算法\n 在这种遍历中，每个根结点都要经过三次：第一次遇到它时立即去处理其左子树，从左子树回到这里就应转到右子树，从右子树回来才应该处理根结点数据，而后返回上一层。\n 上述提供了一种实现方式。栈里每个结点的父结点就是位于它下面的那个结点。若变量t表示当前结点。在实现遍历的循环中维持一种不变关系：\n 如果t不空，其父结点就是栈顶结点 t为空时，栈顶就是应访问的结点。  根据被访问结点是其父结点的左子结点或右子结点，就可以决定下一步怎么做：如果是左子结点就转到右兄弟；如果是右子结点，就应该处理根结点并强制退栈。\n6 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n[2] https://www.jianshu.com/p/9503238394df\n","id":13,"section":"posts","summary":"1 树 树(tree)是一种数据结构，是由有限个($n$个($n\u0026gt;0$))结点组成的具有层次关系的集合，它具有以下的特点： 一个结构如果不空","tags":["树","二叉树"],"title":"数据结构基础之树","uri":"https://wst-casd.github.io/wst.github.io/2021/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%91/","year":"2021"},{"content":"1 概述 队列 ( Queue )是一种先进先出( first in first out )的线性数据结构，插入操作在队尾( rear )进行, 删除操作的队头( front )进行。\n 2 队列的抽象数据类型 ADT Queue: Queue(self) #创建空队列 enqueue(self, elem) #向队尾插入项 dequeue(self) #返回队首的项，并从队列中删除该项 is_empty(self) #判断队列是否为空，空时返回True，否则返回False peek(self) #查看当前队列中最早进入的元素(注意: 不删除) 除了以上的操作，还可能定义size(self)等操作\n3 队列的实现 在实现队列结构之前，先考虑为操作失败的处理定义一个异常类，具体定义如下： class QueueUnderflow(ValueError): pass\n3.1 队列的链接表实现 队列操作要求先进先出，从线性顺序来看，这就要求在表的两端进行操作，可以借鉴带有尾端指针的单链表来实现队列。\nclass LNode(object): def __init__(self, elem, next_=None): self.elem = elem self.next = next_ class LQueue(object): def __init__(self): self._head = None self._rear = None def enqueue(self, elem): if not self._head: self._head = LNode(elem, self._head) self._rear = self._head else: self._rear.next = LNode(elem) self._rear = self._rear.next def dequeue(self): if self._head is None: raise QueueUnderflow(\u0026#34;in dequeue\u0026#34;) e = self._head.elem self._head = self._head.next return e def peek(self): if not self._head: raise QueueUnderflow(\u0026#34;in dequeue\u0026#34;) return self._head.elem def is_empty(self): return self._head is None  3.2 队列的顺序表实现 考虑一种用循环可扩容的顺序表来实现队列。\n class SQueue(object): def __init__(self, init_len=8): self._len = init_len self._elems = [0]*self._len self._head = 0 self._num = 0 def is_empty(self): return self._num == 0 def peek(self): if self._num == 0: raise QueueUnderFlow(\u0026#34;in peek\u0026#34;) return self._elems[self._head] def dequeue(self): if self._num == 0: raise QueueUnderFlow(\u0026#34;in peek\u0026#34;) e = self._elems[self._head] self._head = (self._head + 1) % self._len self._num -= 1 return e def enqueue(self, e): if self._num == self._len: self.__extend() self._elems[(self._head + self._num) % self._len] = e self._num += 1 def __extend(self): old_len = self._len self._len \u0026gt;\u0026gt;= 1 new_elems = [0] * self._len for i in range(old_len): new_elems[i] = self._elems[(self._head + i) % old_len] self._elems, self._head = new_elems, 0 4 队列的应用 在广度优先搜索遍历中，经常使用队列。\n5 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n","id":14,"section":"posts","summary":"1 概述 队列 ( Queue )是一种先进先出( first in first out )的线性数据结构，插入操作在队尾( rear )进行, 删除操作的队头( front )进行。 2 队列的抽象数据类型 ADT Queue: Queue(self) #创","tags":["队列"],"title":"数据结构基础之队列","uri":"https://wst-casd.github.io/wst.github.io/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%9F%E5%88%97/","year":"2021"},{"content":"1 概述 栈 ( Stack )，又称堆栈，是一种后进先出( last in first out )的线性数据结构，对栈的操作只允许在栈的一端(栈顶)进行。\n 1](#baiduxueshu) --  -- 2 栈的抽象数据类型 ADT Stack: Stack(self) # 创建栈 is_empty(self) # 判断栈是否为空 push(self, elem) # 将元素elem加入栈 pop(self) # 删除栈里最后压入的元素，并将其返回 top(self) # 取得栈顶的元素 除了以上的操作，还可能定义clear(self), size(self)等操作。\n3 栈的实现 在实现栈结构之前，先考虑为操作失败的处理定义一个异常类，具体定义如下： class StackUnderflow(ValueError): # 栈下溢(空栈访问) pass\n3.1 栈的顺序表实现 下面是一个栈的定义，其中用一个list类型的数据元素_elems作为栈元素的存储区，把_elems的首端作为栈低，尾端作为栈顶: class SStack(object): def __init__(self): self._elems = [] def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow(\u0026#34;in SStack.top()\u0026#34;) return self._elems[-1] def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow(\u0026#34;in SStack.pop()\u0026#34;) return self._elems.pop()\n3.2 栈的链接表实现 用链接表实现栈的基础结构就是链接表，先定义一下LNode类作为链中的结点: class LNode(object): def __init__(self, elem, next_=None): self.elem = elem self.next = next_ 前面说过，由于所有栈操作都在线性表的一端进行，采用链接表技术，自然可以用表头一端所有栈顶，表尾作为栈低: class LStack(object): def __init__(self): self._top = None def is_empty(self): return not self._top def top(self): if not self._top: raise StackUnderflow(\u0026#34;in LStack.top()\u0026#34;) return self._top.elem def push(self, elem): self._top = LNode(elem, self._top) def pop(self): if not self._top: raise StackUnderflow(\u0026#34;in LStack.pop()\u0026#34;) e = self._top.elem self._top = self._top.next return e\n4 栈的应用 栈有很多经典的应用，尤其是在递归中的应用。在很多状态空间搜索问题中(例如，迷宫问题，八皇后)，作为缓存结构的存储中间状态信息。\n5 参考 [1] 《数据结构与算法 Python语言描述》 裘宗燕 著 机械工业出版社， 2015.12\n [2] http://xueshu.baidu.com -- ","id":15,"section":"posts","summary":"1 概述 栈 ( Stack )，又称堆栈，是一种后进先出( last in first out )的线性数据结构，对栈的操作只允许在栈的一端(栈顶)进行。 1](#baiduxueshu) -- -- 2 栈的抽象数据类型 ADT Stack: Stack(self) #","tags":["堆栈"],"title":"数据结构基础之堆栈","uri":"https://wst-casd.github.io/wst.github.io/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A0%86%E6%A0%88/","year":"2021"}],"tags":[{"title":"二叉排序树","uri":"https://wst-casd.github.io/wst.github.io/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"},{"title":"二叉树","uri":"https://wst-casd.github.io/wst.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"优先队列","uri":"https://wst-casd.github.io/wst.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"title":"冒泡排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"堆","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%A0%86/"},{"title":"堆排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"堆栈","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%A0%86%E6%A0%88/"},{"title":"完全二叉树","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"平衡二叉树","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"归并排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"快速排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"title":"插入排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"树","uri":"https://wst-casd.github.io/wst.github.io/tags/%E6%A0%91/"},{"title":"桶排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"title":"计数排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"title":"选择排序","uri":"https://wst-casd.github.io/wst.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"title":"队列","uri":"https://wst-casd.github.io/wst.github.io/tags/%E9%98%9F%E5%88%97/"}]}